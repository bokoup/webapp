schema {
  query: query_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """measured in seconds"""
  ttl: Int! = 60

  """refresh the cache entry"""
  refresh: Boolean! = false
) on QUERY

"""
columns and relationships of "bid_receipt"
"""
type BidReceipt {
  auctionHouse: String!
  bookkeeper: String!
  bump: Int!
  buyer: String!
  canceledAtOnChain: bigint
  createdAt: timestamptz!
  createdAtOnChain: bigint!
  id: String!
  metadata: String!

  """An object relationship"""
  metadataObject: Metadata
  modifiedAt: timestamptz!
  price: bigint!
  purchaseReceipt: String
  slot: bigint!
  tokenAccount: String
  tokenSize: bigint!
  tradeState: String!
  tradeStateBump: Int!
  writeVersion: bigint!
}

"""
Boolean expression to filter rows from the table "bid_receipt". All fields are combined with a logical 'AND'.
"""
input BidReceiptBoolExp {
  _and: [BidReceiptBoolExp!]
  _not: BidReceiptBoolExp
  _or: [BidReceiptBoolExp!]
  auctionHouse: StringComparisonExp
  bookkeeper: StringComparisonExp
  bump: IntComparisonExp
  buyer: StringComparisonExp
  canceledAtOnChain: BigintComparisonExp
  createdAt: TimestamptzComparisonExp
  createdAtOnChain: BigintComparisonExp
  id: StringComparisonExp
  metadata: StringComparisonExp
  metadataObject: MetadataBoolExp
  modifiedAt: TimestamptzComparisonExp
  price: BigintComparisonExp
  purchaseReceipt: StringComparisonExp
  slot: BigintComparisonExp
  tokenAccount: StringComparisonExp
  tokenSize: BigintComparisonExp
  tradeState: StringComparisonExp
  tradeStateBump: IntComparisonExp
  writeVersion: BigintComparisonExp
}

"""Ordering options when selecting data from "bid_receipt"."""
input BidReceiptOrderBy {
  auctionHouse: OrderBy
  bookkeeper: OrderBy
  bump: OrderBy
  buyer: OrderBy
  canceledAtOnChain: OrderBy
  createdAt: OrderBy
  createdAtOnChain: OrderBy
  id: OrderBy
  metadata: OrderBy
  metadataObject: MetadataOrderBy
  modifiedAt: OrderBy
  price: OrderBy
  purchaseReceipt: OrderBy
  slot: OrderBy
  tokenAccount: OrderBy
  tokenSize: OrderBy
  tradeState: OrderBy
  tradeStateBump: OrderBy
  writeVersion: OrderBy
}

"""
select columns of table "bid_receipt"
"""
enum BidReceiptSelectColumn {
  """column name"""
  auctionHouse

  """column name"""
  bookkeeper

  """column name"""
  bump

  """column name"""
  buyer

  """column name"""
  canceledAtOnChain

  """column name"""
  createdAt

  """column name"""
  createdAtOnChain

  """column name"""
  id

  """column name"""
  metadata

  """column name"""
  modifiedAt

  """column name"""
  price

  """column name"""
  purchaseReceipt

  """column name"""
  slot

  """column name"""
  tokenAccount

  """column name"""
  tokenSize

  """column name"""
  tradeState

  """column name"""
  tradeStateBump

  """column name"""
  writeVersion
}

"""
Streaming cursor of the table "bid_receipt"
"""
input BidReceiptStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: BidReceiptStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input BidReceiptStreamCursorValueInput {
  auctionHouse: String
  bookkeeper: String
  bump: Int
  buyer: String
  canceledAtOnChain: bigint
  createdAt: timestamptz
  createdAtOnChain: bigint
  id: String
  metadata: String
  modifiedAt: timestamptz
  price: bigint
  purchaseReceipt: String
  slot: bigint
  tokenAccount: String
  tokenSize: bigint
  tradeState: String
  tradeStateBump: Int
  writeVersion: bigint
}

"""
Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'.
"""
input BigintComparisonExp {
  _eq: bigint
  _gt: bigint
  _gte: bigint
  _in: [bigint!]
  _isNull: Boolean
  _lt: bigint
  _lte: bigint
  _neq: bigint
  _nin: [bigint!]
}

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input BooleanComparisonExp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _isNull: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""
columns and relationships of "burn_delegated_promo_token"
"""
type BurnDelegatedPromoToken {
  adminSettings: String!
  authority: String!
  campaign: String!
  createdAt: timestamptz!
  device: String!
  location: String!
  memo(
    """JSON select path"""
    path: String
  ): jsonb
  mint: String!

  """An object relationship"""
  mintObject: Mint
  modifiedAt: timestamptz!
  payer: String!
  platform: String!
  promo: String!

  """An object relationship"""
  promoObject: Promo
  signature: String!
  slot: bigint!
  tokenAccount: String!

  """An object relationship"""
  tokenAccountObject: TokenAccount
}

"""
Boolean expression to filter rows from the table "burn_delegated_promo_token". All fields are combined with a logical 'AND'.
"""
input BurnDelegatedPromoTokenBoolExp {
  _and: [BurnDelegatedPromoTokenBoolExp!]
  _not: BurnDelegatedPromoTokenBoolExp
  _or: [BurnDelegatedPromoTokenBoolExp!]
  adminSettings: StringComparisonExp
  authority: StringComparisonExp
  campaign: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  device: StringComparisonExp
  location: StringComparisonExp
  memo: JsonbComparisonExp
  mint: StringComparisonExp
  mintObject: MintBoolExp
  modifiedAt: TimestamptzComparisonExp
  payer: StringComparisonExp
  platform: StringComparisonExp
  promo: StringComparisonExp
  promoObject: PromoBoolExp
  signature: StringComparisonExp
  slot: BigintComparisonExp
  tokenAccount: StringComparisonExp
  tokenAccountObject: TokenAccountBoolExp
}

"""
Ordering options when selecting data from "burn_delegated_promo_token".
"""
input BurnDelegatedPromoTokenOrderBy {
  adminSettings: OrderBy
  authority: OrderBy
  campaign: OrderBy
  createdAt: OrderBy
  device: OrderBy
  location: OrderBy
  memo: OrderBy
  mint: OrderBy
  mintObject: MintOrderBy
  modifiedAt: OrderBy
  payer: OrderBy
  platform: OrderBy
  promo: OrderBy
  promoObject: PromoOrderBy
  signature: OrderBy
  slot: OrderBy
  tokenAccount: OrderBy
  tokenAccountObject: TokenAccountOrderBy
}

"""
select columns of table "burn_delegated_promo_token"
"""
enum BurnDelegatedPromoTokenSelectColumn {
  """column name"""
  adminSettings

  """column name"""
  authority

  """column name"""
  campaign

  """column name"""
  createdAt

  """column name"""
  device

  """column name"""
  location

  """column name"""
  memo

  """column name"""
  mint

  """column name"""
  modifiedAt

  """column name"""
  payer

  """column name"""
  platform

  """column name"""
  promo

  """column name"""
  signature

  """column name"""
  slot

  """column name"""
  tokenAccount
}

"""
Streaming cursor of the table "burn_delegated_promo_token"
"""
input BurnDelegatedPromoTokenStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: BurnDelegatedPromoTokenStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input BurnDelegatedPromoTokenStreamCursorValueInput {
  adminSettings: String
  authority: String
  campaign: String
  createdAt: timestamptz
  device: String
  location: String
  memo: jsonb
  mint: String
  modifiedAt: timestamptz
  payer: String
  platform: String
  promo: String
  signature: String
  slot: bigint
  tokenAccount: String
}

"""
columns and relationships of "campaign"
"""
type Campaign {
  active: Boolean!
  createdAt: timestamptz!
  id: String!
  locations(
    """JSON select path"""
    path: String
  ): jsonb!
  merchant: String!
  metadataJson(
    """JSON select path"""
    path: String
  ): jsonb
  modifiedAt: timestamptz!
  name: String!

  """An array relationship"""
  promos(
    """distinct select on columns"""
    distinctOn: [PromoSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromoOrderBy!]

    """filter the rows returned"""
    where: PromoBoolExp
  ): [Promo!]!
  slot: bigint!
  uri: String!
  writeVersion: bigint!
}

"""
order by aggregate values of table "campaign"
"""
input CampaignAggregateOrderBy {
  avg: campaign_avg_order_by
  count: OrderBy
  max: campaign_max_order_by
  min: campaign_min_order_by
  stddev: campaign_stddev_order_by
  stddev_pop: campaign_stddev_pop_order_by
  stddev_samp: campaign_stddev_samp_order_by
  sum: campaign_sum_order_by
  var_pop: campaign_var_pop_order_by
  var_samp: campaign_var_samp_order_by
  variance: campaign_variance_order_by
}

"""
Boolean expression to filter rows from the table "campaign". All fields are combined with a logical 'AND'.
"""
input CampaignBoolExp {
  _and: [CampaignBoolExp!]
  _not: CampaignBoolExp
  _or: [CampaignBoolExp!]
  active: BooleanComparisonExp
  createdAt: TimestamptzComparisonExp
  id: StringComparisonExp
  locations: JsonbComparisonExp
  merchant: StringComparisonExp
  metadataJson: JsonbComparisonExp
  modifiedAt: TimestamptzComparisonExp
  name: StringComparisonExp
  promos: PromoBoolExp
  slot: BigintComparisonExp
  uri: StringComparisonExp
  writeVersion: BigintComparisonExp
}

"""Ordering options when selecting data from "campaign"."""
input CampaignOrderBy {
  active: OrderBy
  createdAt: OrderBy
  id: OrderBy
  locations: OrderBy
  merchant: OrderBy
  metadataJson: OrderBy
  modifiedAt: OrderBy
  name: OrderBy
  promosAggregate: PromoAggregateOrderBy
  slot: OrderBy
  uri: OrderBy
  writeVersion: OrderBy
}

"""
select columns of table "campaign"
"""
enum CampaignSelectColumn {
  """column name"""
  active

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  locations

  """column name"""
  merchant

  """column name"""
  metadataJson

  """column name"""
  modifiedAt

  """column name"""
  name

  """column name"""
  slot

  """column name"""
  uri

  """column name"""
  writeVersion
}

"""
Streaming cursor of the table "campaign"
"""
input CampaignStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: CampaignStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input CampaignStreamCursorValueInput {
  active: Boolean
  createdAt: timestamptz
  id: String
  locations: jsonb
  merchant: String
  metadataJson: jsonb
  modifiedAt: timestamptz
  name: String
  slot: bigint
  uri: String
  writeVersion: bigint
}

"""ordering argument of a cursor"""
enum CursorOrdering {
  """ascending ordering of the cursor"""
  ASC

  """descending ordering of the cursor"""
  DESC
}

"""
columns and relationships of "delegate_promo_token"
"""
type DelegatePromoToken {
  campaign: String!
  createdAt: timestamptz!
  device: String!
  deviceOwner: String!
  location: String!
  memo(
    """JSON select path"""
    path: String
  ): jsonb
  mint: String!
  modifiedAt: timestamptz!
  payer: String!
  promo: String!

  """An object relationship"""
  promoObject: Promo
  signature: String!
  slot: bigint!
  tokenAccount: String!

  """An object relationship"""
  tokenAccountObject: TokenAccount
  tokenOwner: String!
}

"""
Boolean expression to filter rows from the table "delegate_promo_token". All fields are combined with a logical 'AND'.
"""
input DelegatePromoTokenBoolExp {
  _and: [DelegatePromoTokenBoolExp!]
  _not: DelegatePromoTokenBoolExp
  _or: [DelegatePromoTokenBoolExp!]
  campaign: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  device: StringComparisonExp
  deviceOwner: StringComparisonExp
  location: StringComparisonExp
  memo: JsonbComparisonExp
  mint: StringComparisonExp
  modifiedAt: TimestamptzComparisonExp
  payer: StringComparisonExp
  promo: StringComparisonExp
  promoObject: PromoBoolExp
  signature: StringComparisonExp
  slot: BigintComparisonExp
  tokenAccount: StringComparisonExp
  tokenAccountObject: TokenAccountBoolExp
  tokenOwner: StringComparisonExp
}

"""Ordering options when selecting data from "delegate_promo_token"."""
input DelegatePromoTokenOrderBy {
  campaign: OrderBy
  createdAt: OrderBy
  device: OrderBy
  deviceOwner: OrderBy
  location: OrderBy
  memo: OrderBy
  mint: OrderBy
  modifiedAt: OrderBy
  payer: OrderBy
  promo: OrderBy
  promoObject: PromoOrderBy
  signature: OrderBy
  slot: OrderBy
  tokenAccount: OrderBy
  tokenAccountObject: TokenAccountOrderBy
  tokenOwner: OrderBy
}

"""
select columns of table "delegate_promo_token"
"""
enum DelegatePromoTokenSelectColumn {
  """column name"""
  campaign

  """column name"""
  createdAt

  """column name"""
  device

  """column name"""
  deviceOwner

  """column name"""
  location

  """column name"""
  memo

  """column name"""
  mint

  """column name"""
  modifiedAt

  """column name"""
  payer

  """column name"""
  promo

  """column name"""
  signature

  """column name"""
  slot

  """column name"""
  tokenAccount

  """column name"""
  tokenOwner
}

"""
Streaming cursor of the table "delegate_promo_token"
"""
input DelegatePromoTokenStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: DelegatePromoTokenStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input DelegatePromoTokenStreamCursorValueInput {
  campaign: String
  createdAt: timestamptz
  device: String
  deviceOwner: String
  location: String
  memo: jsonb
  mint: String
  modifiedAt: timestamptz
  payer: String
  promo: String
  signature: String
  slot: bigint
  tokenAccount: String
  tokenOwner: String
}

"""
columns and relationships of "device"
"""
type Device {
  active: Boolean!
  createdAt: timestamptz!
  id: String!
  location: String!

  """An object relationship"""
  locationObject: Location
  metadataJson(
    """JSON select path"""
    path: String
  ): jsonb
  modifiedAt: timestamptz!
  name: String!
  owner: String!
  slot: bigint!
  uri: String!
  writeVersion: bigint!
}

"""
aggregated selection of "device"
"""
type DeviceAggregate {
  aggregate: DeviceAggregateFields
  nodes: [Device!]!
}

"""
aggregate fields of "device"
"""
type DeviceAggregateFields {
  avg: DeviceAvgFields
  count(columns: [DeviceSelectColumn!], distinct: Boolean): Int!
  max: DeviceMaxFields
  min: DeviceMinFields
  stddev: DeviceStddevFields
  stddevPop: DeviceStddev_popFields
  stddevSamp: DeviceStddev_sampFields
  sum: DeviceSumFields
  varPop: DeviceVar_popFields
  varSamp: DeviceVar_sampFields
  variance: DeviceVarianceFields
}

"""
order by aggregate values of table "device"
"""
input DeviceAggregateOrderBy {
  avg: device_avg_order_by
  count: OrderBy
  max: device_max_order_by
  min: device_min_order_by
  stddev: device_stddev_order_by
  stddev_pop: device_stddev_pop_order_by
  stddev_samp: device_stddev_samp_order_by
  sum: device_sum_order_by
  var_pop: device_var_pop_order_by
  var_samp: device_var_samp_order_by
  variance: device_variance_order_by
}

"""aggregate avg on columns"""
type DeviceAvgFields {
  slot: Float
  writeVersion: Float
}

"""
Boolean expression to filter rows from the table "device". All fields are combined with a logical 'AND'.
"""
input DeviceBoolExp {
  _and: [DeviceBoolExp!]
  _not: DeviceBoolExp
  _or: [DeviceBoolExp!]
  active: BooleanComparisonExp
  createdAt: TimestamptzComparisonExp
  id: StringComparisonExp
  location: StringComparisonExp
  locationObject: LocationBoolExp
  metadataJson: JsonbComparisonExp
  modifiedAt: TimestamptzComparisonExp
  name: StringComparisonExp
  owner: StringComparisonExp
  slot: BigintComparisonExp
  uri: StringComparisonExp
  writeVersion: BigintComparisonExp
}

"""aggregate max on columns"""
type DeviceMaxFields {
  createdAt: timestamptz
  id: String
  location: String
  modifiedAt: timestamptz
  name: String
  owner: String
  slot: bigint
  uri: String
  writeVersion: bigint
}

"""aggregate min on columns"""
type DeviceMinFields {
  createdAt: timestamptz
  id: String
  location: String
  modifiedAt: timestamptz
  name: String
  owner: String
  slot: bigint
  uri: String
  writeVersion: bigint
}

"""Ordering options when selecting data from "device"."""
input DeviceOrderBy {
  active: OrderBy
  createdAt: OrderBy
  id: OrderBy
  location: OrderBy
  locationObject: LocationOrderBy
  metadataJson: OrderBy
  modifiedAt: OrderBy
  name: OrderBy
  owner: OrderBy
  slot: OrderBy
  uri: OrderBy
  writeVersion: OrderBy
}

"""
select columns of table "device"
"""
enum DeviceSelectColumn {
  """column name"""
  active

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  location

  """column name"""
  metadataJson

  """column name"""
  modifiedAt

  """column name"""
  name

  """column name"""
  owner

  """column name"""
  slot

  """column name"""
  uri

  """column name"""
  writeVersion
}

"""aggregate stddev on columns"""
type DeviceStddevFields {
  slot: Float
  writeVersion: Float
}

"""aggregate stddev_pop on columns"""
type DeviceStddev_popFields {
  slot: Float
  writeVersion: Float
}

"""aggregate stddev_samp on columns"""
type DeviceStddev_sampFields {
  slot: Float
  writeVersion: Float
}

"""
Streaming cursor of the table "device"
"""
input DeviceStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: DeviceStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input DeviceStreamCursorValueInput {
  active: Boolean
  createdAt: timestamptz
  id: String
  location: String
  metadataJson: jsonb
  modifiedAt: timestamptz
  name: String
  owner: String
  slot: bigint
  uri: String
  writeVersion: bigint
}

"""aggregate sum on columns"""
type DeviceSumFields {
  slot: bigint
  writeVersion: bigint
}

"""aggregate var_pop on columns"""
type DeviceVar_popFields {
  slot: Float
  writeVersion: Float
}

"""aggregate var_samp on columns"""
type DeviceVar_sampFields {
  slot: Float
  writeVersion: Float
}

"""aggregate variance on columns"""
type DeviceVarianceFields {
  slot: Float
  writeVersion: Float
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input IntComparisonExp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _isNull: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

input JsonbCastExp {
  String: StringComparisonExp
}

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input JsonbComparisonExp {
  _cast: JsonbCastExp

  """is the column contained in the given json value"""
  _containedIn: jsonb

  """does the column contain the given json value at the top level"""
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  """does the string exist as a top-level key in the column"""
  _hasKey: String

  """do all of these strings exist as top-level keys in the column"""
  _hasKeysAll: [String!]

  """do any of these strings exist as top-level keys in the column"""
  _hasKeysAny: [String!]
  _in: [jsonb!]
  _isNull: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

"""
columns and relationships of "listing_receipt"
"""
type ListingReceipt {
  auctionHouse: String!
  bookkeeper: String!
  bump: Int!
  canceledAtOnChain: bigint
  createdAt: timestamptz!
  createdAtOnChain: bigint!
  id: String!
  metadata: String!
  modifiedAt: timestamptz!
  price: bigint!
  purchaseReceipt: String
  seller: String!
  slot: bigint!
  tokenSize: bigint!
  tradeState: String!
  tradeStateBump: Int!
  writeVersion: bigint!
}

"""
Boolean expression to filter rows from the table "listing_receipt". All fields are combined with a logical 'AND'.
"""
input ListingReceiptBoolExp {
  _and: [ListingReceiptBoolExp!]
  _not: ListingReceiptBoolExp
  _or: [ListingReceiptBoolExp!]
  auctionHouse: StringComparisonExp
  bookkeeper: StringComparisonExp
  bump: IntComparisonExp
  canceledAtOnChain: BigintComparisonExp
  createdAt: TimestamptzComparisonExp
  createdAtOnChain: BigintComparisonExp
  id: StringComparisonExp
  metadata: StringComparisonExp
  modifiedAt: TimestamptzComparisonExp
  price: BigintComparisonExp
  purchaseReceipt: StringComparisonExp
  seller: StringComparisonExp
  slot: BigintComparisonExp
  tokenSize: BigintComparisonExp
  tradeState: StringComparisonExp
  tradeStateBump: IntComparisonExp
  writeVersion: BigintComparisonExp
}

"""Ordering options when selecting data from "listing_receipt"."""
input ListingReceiptOrderBy {
  auctionHouse: OrderBy
  bookkeeper: OrderBy
  bump: OrderBy
  canceledAtOnChain: OrderBy
  createdAt: OrderBy
  createdAtOnChain: OrderBy
  id: OrderBy
  metadata: OrderBy
  modifiedAt: OrderBy
  price: OrderBy
  purchaseReceipt: OrderBy
  seller: OrderBy
  slot: OrderBy
  tokenSize: OrderBy
  tradeState: OrderBy
  tradeStateBump: OrderBy
  writeVersion: OrderBy
}

"""
select columns of table "listing_receipt"
"""
enum ListingReceiptSelectColumn {
  """column name"""
  auctionHouse

  """column name"""
  bookkeeper

  """column name"""
  bump

  """column name"""
  canceledAtOnChain

  """column name"""
  createdAt

  """column name"""
  createdAtOnChain

  """column name"""
  id

  """column name"""
  metadata

  """column name"""
  modifiedAt

  """column name"""
  price

  """column name"""
  purchaseReceipt

  """column name"""
  seller

  """column name"""
  slot

  """column name"""
  tokenSize

  """column name"""
  tradeState

  """column name"""
  tradeStateBump

  """column name"""
  writeVersion
}

"""
Streaming cursor of the table "listing_receipt"
"""
input ListingReceiptStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ListingReceiptStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ListingReceiptStreamCursorValueInput {
  auctionHouse: String
  bookkeeper: String
  bump: Int
  canceledAtOnChain: bigint
  createdAt: timestamptz
  createdAtOnChain: bigint
  id: String
  metadata: String
  modifiedAt: timestamptz
  price: bigint
  purchaseReceipt: String
  seller: String
  slot: bigint
  tokenSize: bigint
  tradeState: String
  tradeStateBump: Int
  writeVersion: bigint
}

"""
columns and relationships of "listing_with_token"
"""
type ListingWithToken {
  createdAtOnChain: bigint
  id: String
  metadata: String
  mint: String

  """An object relationship"""
  mintObject: Mint
  price: bigint
  seller: String
  slot: bigint
  tokenAccount: String
  tokenSize: bigint
}

"""
Boolean expression to filter rows from the table "listing_with_token". All fields are combined with a logical 'AND'.
"""
input ListingWithTokenBoolExp {
  _and: [ListingWithTokenBoolExp!]
  _not: ListingWithTokenBoolExp
  _or: [ListingWithTokenBoolExp!]
  createdAtOnChain: BigintComparisonExp
  id: StringComparisonExp
  metadata: StringComparisonExp
  mint: StringComparisonExp
  mintObject: MintBoolExp
  price: BigintComparisonExp
  seller: StringComparisonExp
  slot: BigintComparisonExp
  tokenAccount: StringComparisonExp
  tokenSize: BigintComparisonExp
}

"""Ordering options when selecting data from "listing_with_token"."""
input ListingWithTokenOrderBy {
  createdAtOnChain: OrderBy
  id: OrderBy
  metadata: OrderBy
  mint: OrderBy
  mintObject: MintOrderBy
  price: OrderBy
  seller: OrderBy
  slot: OrderBy
  tokenAccount: OrderBy
  tokenSize: OrderBy
}

"""
select columns of table "listing_with_token"
"""
enum ListingWithTokenSelectColumn {
  """column name"""
  createdAtOnChain

  """column name"""
  id

  """column name"""
  metadata

  """column name"""
  mint

  """column name"""
  price

  """column name"""
  seller

  """column name"""
  slot

  """column name"""
  tokenAccount

  """column name"""
  tokenSize
}

"""
Streaming cursor of the table "listing_with_token"
"""
input ListingWithTokenStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ListingWithTokenStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ListingWithTokenStreamCursorValueInput {
  createdAtOnChain: bigint
  id: String
  metadata: String
  mint: String
  price: bigint
  seller: String
  slot: bigint
  tokenAccount: String
  tokenSize: bigint
}

"""
columns and relationships of "location"
"""
type Location {
  active: Boolean!
  createdAt: timestamptz!

  """An array relationship"""
  devices(
    """distinct select on columns"""
    distinctOn: [DeviceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [DeviceOrderBy!]

    """filter the rows returned"""
    where: DeviceBoolExp
  ): [Device!]!

  """An aggregate relationship"""
  devicesAggregate(
    """distinct select on columns"""
    distinctOn: [DeviceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [DeviceOrderBy!]

    """filter the rows returned"""
    where: DeviceBoolExp
  ): DeviceAggregate!
  id: String!
  merchant: String!

  """An object relationship"""
  merchantObject: Merchant
  metadataJson(
    """JSON select path"""
    path: String
  ): jsonb
  modifiedAt: timestamptz!
  name: String!
  slot: bigint!
  uri: String!
  writeVersion: bigint!
}

"""
order by aggregate values of table "location"
"""
input LocationAggregateOrderBy {
  avg: location_avg_order_by
  count: OrderBy
  max: location_max_order_by
  min: location_min_order_by
  stddev: location_stddev_order_by
  stddev_pop: location_stddev_pop_order_by
  stddev_samp: location_stddev_samp_order_by
  sum: location_sum_order_by
  var_pop: location_var_pop_order_by
  var_samp: location_var_samp_order_by
  variance: location_variance_order_by
}

"""
Boolean expression to filter rows from the table "location". All fields are combined with a logical 'AND'.
"""
input LocationBoolExp {
  _and: [LocationBoolExp!]
  _not: LocationBoolExp
  _or: [LocationBoolExp!]
  active: BooleanComparisonExp
  createdAt: TimestamptzComparisonExp
  devices: DeviceBoolExp
  devices_aggregate: device_aggregate_bool_exp
  id: StringComparisonExp
  merchant: StringComparisonExp
  merchantObject: MerchantBoolExp
  metadataJson: JsonbComparisonExp
  modifiedAt: TimestamptzComparisonExp
  name: StringComparisonExp
  slot: BigintComparisonExp
  uri: StringComparisonExp
  writeVersion: BigintComparisonExp
}

"""Ordering options when selecting data from "location"."""
input LocationOrderBy {
  active: OrderBy
  createdAt: OrderBy
  devicesAggregate: DeviceAggregateOrderBy
  id: OrderBy
  merchant: OrderBy
  merchantObject: MerchantOrderBy
  metadataJson: OrderBy
  modifiedAt: OrderBy
  name: OrderBy
  slot: OrderBy
  uri: OrderBy
  writeVersion: OrderBy
}

"""
select columns of table "location"
"""
enum LocationSelectColumn {
  """column name"""
  active

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  merchant

  """column name"""
  metadataJson

  """column name"""
  modifiedAt

  """column name"""
  name

  """column name"""
  slot

  """column name"""
  uri

  """column name"""
  writeVersion
}

"""
Streaming cursor of the table "location"
"""
input LocationStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: LocationStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input LocationStreamCursorValueInput {
  active: Boolean
  createdAt: timestamptz
  id: String
  merchant: String
  metadataJson: jsonb
  modifiedAt: timestamptz
  name: String
  slot: bigint
  uri: String
  writeVersion: bigint
}

"""
columns and relationships of "merchant"
"""
type Merchant {
  active: Boolean!

  """An array relationship"""
  campaigns(
    """distinct select on columns"""
    distinctOn: [CampaignSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CampaignOrderBy!]

    """filter the rows returned"""
    where: CampaignBoolExp
  ): [Campaign!]!
  createdAt: timestamptz!
  id: String!

  """An array relationship"""
  locations(
    """distinct select on columns"""
    distinctOn: [LocationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [LocationOrderBy!]

    """filter the rows returned"""
    where: LocationBoolExp
  ): [Location!]!
  metadataJson(
    """JSON select path"""
    path: String
  ): jsonb
  modifiedAt: timestamptz!
  name: String!
  owner: String!
  slot: bigint!
  uri: String!
  writeVersion: bigint!
}

"""
Boolean expression to filter rows from the table "merchant". All fields are combined with a logical 'AND'.
"""
input MerchantBoolExp {
  _and: [MerchantBoolExp!]
  _not: MerchantBoolExp
  _or: [MerchantBoolExp!]
  active: BooleanComparisonExp
  campaigns: CampaignBoolExp
  createdAt: TimestamptzComparisonExp
  id: StringComparisonExp
  locations: LocationBoolExp
  metadataJson: JsonbComparisonExp
  modifiedAt: TimestamptzComparisonExp
  name: StringComparisonExp
  owner: StringComparisonExp
  slot: BigintComparisonExp
  uri: StringComparisonExp
  writeVersion: BigintComparisonExp
}

"""Ordering options when selecting data from "merchant"."""
input MerchantOrderBy {
  active: OrderBy
  campaignsAggregate: CampaignAggregateOrderBy
  createdAt: OrderBy
  id: OrderBy
  locationsAggregate: LocationAggregateOrderBy
  metadataJson: OrderBy
  modifiedAt: OrderBy
  name: OrderBy
  owner: OrderBy
  slot: OrderBy
  uri: OrderBy
  writeVersion: OrderBy
}

"""
select columns of table "merchant"
"""
enum MerchantSelectColumn {
  """column name"""
  active

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  metadataJson

  """column name"""
  modifiedAt

  """column name"""
  name

  """column name"""
  owner

  """column name"""
  slot

  """column name"""
  uri

  """column name"""
  writeVersion
}

"""
Streaming cursor of the table "merchant"
"""
input MerchantStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: MerchantStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input MerchantStreamCursorValueInput {
  active: Boolean
  createdAt: timestamptz
  id: String
  metadataJson: jsonb
  modifiedAt: timestamptz
  name: String
  owner: String
  slot: bigint
  uri: String
  writeVersion: bigint
}

"""
columns and relationships of "metadata"
"""
type Metadata {
  collectionKey: String
  collectionVerified: Boolean
  createdAt: timestamptz!
  editionNonce: Int
  id: String!
  isMutable: Boolean!
  key: String!
  metadataJson(
    """JSON select path"""
    path: String
  ): jsonb
  mint: String!

  """An object relationship"""
  mintObject: Mint
  modifiedAt: timestamptz!
  name: String!
  primarySaleHappened: Boolean!
  sellerFeeBasisPoints: Int!
  slot: bigint!
  symbol: String!
  tokenStandard: String
  updateAuthority: String!
  uri: String!
  usesRemaining: bigint
  usesTotal: bigint
  usesUseMethod: String
  writeVersion: bigint!
}

"""
Boolean expression to filter rows from the table "metadata". All fields are combined with a logical 'AND'.
"""
input MetadataBoolExp {
  _and: [MetadataBoolExp!]
  _not: MetadataBoolExp
  _or: [MetadataBoolExp!]
  collectionKey: StringComparisonExp
  collectionVerified: BooleanComparisonExp
  createdAt: TimestamptzComparisonExp
  editionNonce: IntComparisonExp
  id: StringComparisonExp
  isMutable: BooleanComparisonExp
  key: StringComparisonExp
  metadataJson: JsonbComparisonExp
  mint: StringComparisonExp
  mintObject: MintBoolExp
  modifiedAt: TimestamptzComparisonExp
  name: StringComparisonExp
  primarySaleHappened: BooleanComparisonExp
  sellerFeeBasisPoints: IntComparisonExp
  slot: BigintComparisonExp
  symbol: StringComparisonExp
  tokenStandard: StringComparisonExp
  updateAuthority: StringComparisonExp
  uri: StringComparisonExp
  usesRemaining: BigintComparisonExp
  usesTotal: BigintComparisonExp
  usesUseMethod: StringComparisonExp
  writeVersion: BigintComparisonExp
}

"""Ordering options when selecting data from "metadata"."""
input MetadataOrderBy {
  collectionKey: OrderBy
  collectionVerified: OrderBy
  createdAt: OrderBy
  editionNonce: OrderBy
  id: OrderBy
  isMutable: OrderBy
  key: OrderBy
  metadataJson: OrderBy
  mint: OrderBy
  mintObject: MintOrderBy
  modifiedAt: OrderBy
  name: OrderBy
  primarySaleHappened: OrderBy
  sellerFeeBasisPoints: OrderBy
  slot: OrderBy
  symbol: OrderBy
  tokenStandard: OrderBy
  updateAuthority: OrderBy
  uri: OrderBy
  usesRemaining: OrderBy
  usesTotal: OrderBy
  usesUseMethod: OrderBy
  writeVersion: OrderBy
}

"""
select columns of table "metadata"
"""
enum MetadataSelectColumn {
  """column name"""
  collectionKey

  """column name"""
  collectionVerified

  """column name"""
  createdAt

  """column name"""
  editionNonce

  """column name"""
  id

  """column name"""
  isMutable

  """column name"""
  key

  """column name"""
  metadataJson

  """column name"""
  mint

  """column name"""
  modifiedAt

  """column name"""
  name

  """column name"""
  primarySaleHappened

  """column name"""
  sellerFeeBasisPoints

  """column name"""
  slot

  """column name"""
  symbol

  """column name"""
  tokenStandard

  """column name"""
  updateAuthority

  """column name"""
  uri

  """column name"""
  usesRemaining

  """column name"""
  usesTotal

  """column name"""
  usesUseMethod

  """column name"""
  writeVersion
}

"""
Streaming cursor of the table "metadata"
"""
input MetadataStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: MetadataStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input MetadataStreamCursorValueInput {
  collectionKey: String
  collectionVerified: Boolean
  createdAt: timestamptz
  editionNonce: Int
  id: String
  isMutable: Boolean
  key: String
  metadataJson: jsonb
  mint: String
  modifiedAt: timestamptz
  name: String
  primarySaleHappened: Boolean
  sellerFeeBasisPoints: Int
  slot: bigint
  symbol: String
  tokenStandard: String
  updateAuthority: String
  uri: String
  usesRemaining: bigint
  usesTotal: bigint
  usesUseMethod: String
  writeVersion: bigint
}

"""
columns and relationships of "mint"
"""
type Mint {
  createdAt: timestamptz
  decimals: Int!
  freezeAuthority: String
  id: String!
  isInitialized: Boolean!
  mintAuthority: String
  modifiedAt: timestamptz

  """An object relationship"""
  promoObject: Promo
  slot: bigint!
  supply: bigint!

  """An array relationship"""
  tokenAccounts(
    """distinct select on columns"""
    distinctOn: [TokenAccountSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TokenAccountOrderBy!]

    """filter the rows returned"""
    where: TokenAccountBoolExp
  ): [TokenAccount!]!
  writeVersion: bigint!
}

"""
Boolean expression to filter rows from the table "mint". All fields are combined with a logical 'AND'.
"""
input MintBoolExp {
  _and: [MintBoolExp!]
  _not: MintBoolExp
  _or: [MintBoolExp!]
  createdAt: TimestamptzComparisonExp
  decimals: IntComparisonExp
  freezeAuthority: StringComparisonExp
  id: StringComparisonExp
  isInitialized: BooleanComparisonExp
  mintAuthority: StringComparisonExp
  modifiedAt: TimestamptzComparisonExp
  promoObject: PromoBoolExp
  slot: BigintComparisonExp
  supply: BigintComparisonExp
  tokenAccounts: TokenAccountBoolExp
  writeVersion: BigintComparisonExp
}

"""Ordering options when selecting data from "mint"."""
input MintOrderBy {
  createdAt: OrderBy
  decimals: OrderBy
  freezeAuthority: OrderBy
  id: OrderBy
  isInitialized: OrderBy
  mintAuthority: OrderBy
  modifiedAt: OrderBy
  promoObject: PromoOrderBy
  slot: OrderBy
  supply: OrderBy
  tokenAccountsAggregate: TokenAccountAggregateOrderBy
  writeVersion: OrderBy
}

"""
columns and relationships of "mint_promo_token"
"""
type MintPromoToken {
  authority: String!
  createdAt: timestamptz!
  memo(
    """JSON select path"""
    path: String
  ): jsonb
  mint: String!

  """An object relationship"""
  mintObject: Mint
  modifiedAt: timestamptz!
  payer: String!
  promo: String!

  """An object relationship"""
  promoObject: Promo
  signature: String!
  slot: bigint!
  tokenAccount: String!
  tokenOwner: String!
}

"""
Boolean expression to filter rows from the table "mint_promo_token". All fields are combined with a logical 'AND'.
"""
input MintPromoTokenBoolExp {
  _and: [MintPromoTokenBoolExp!]
  _not: MintPromoTokenBoolExp
  _or: [MintPromoTokenBoolExp!]
  authority: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  memo: JsonbComparisonExp
  mint: StringComparisonExp
  mintObject: MintBoolExp
  modifiedAt: TimestamptzComparisonExp
  payer: StringComparisonExp
  promo: StringComparisonExp
  promoObject: PromoBoolExp
  signature: StringComparisonExp
  slot: BigintComparisonExp
  tokenAccount: StringComparisonExp
  tokenOwner: StringComparisonExp
}

"""Ordering options when selecting data from "mint_promo_token"."""
input MintPromoTokenOrderBy {
  authority: OrderBy
  createdAt: OrderBy
  memo: OrderBy
  mint: OrderBy
  mintObject: MintOrderBy
  modifiedAt: OrderBy
  payer: OrderBy
  promo: OrderBy
  promoObject: PromoOrderBy
  signature: OrderBy
  slot: OrderBy
  tokenAccount: OrderBy
  tokenOwner: OrderBy
}

"""
select columns of table "mint_promo_token"
"""
enum MintPromoTokenSelectColumn {
  """column name"""
  authority

  """column name"""
  createdAt

  """column name"""
  memo

  """column name"""
  mint

  """column name"""
  modifiedAt

  """column name"""
  payer

  """column name"""
  promo

  """column name"""
  signature

  """column name"""
  slot

  """column name"""
  tokenAccount

  """column name"""
  tokenOwner
}

"""
Streaming cursor of the table "mint_promo_token"
"""
input MintPromoTokenStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: MintPromoTokenStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input MintPromoTokenStreamCursorValueInput {
  authority: String
  createdAt: timestamptz
  memo: jsonb
  mint: String
  modifiedAt: timestamptz
  payer: String
  promo: String
  signature: String
  slot: bigint
  tokenAccount: String
  tokenOwner: String
}

"""
select columns of table "mint"
"""
enum MintSelectColumn {
  """column name"""
  createdAt

  """column name"""
  decimals

  """column name"""
  freezeAuthority

  """column name"""
  id

  """column name"""
  isInitialized

  """column name"""
  mintAuthority

  """column name"""
  modifiedAt

  """column name"""
  slot

  """column name"""
  supply

  """column name"""
  writeVersion
}

"""
Streaming cursor of the table "mint"
"""
input MintStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: MintStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input MintStreamCursorValueInput {
  createdAt: timestamptz
  decimals: Int
  freezeAuthority: String
  id: String
  isInitialized: Boolean
  mintAuthority: String
  modifiedAt: timestamptz
  slot: bigint
  supply: bigint
  writeVersion: bigint
}

"""column ordering options"""
enum OrderBy {
  """in ascending order, nulls last"""
  ASC

  """in ascending order, nulls first"""
  ASC_NULLS_FIRST

  """in ascending order, nulls last"""
  ASC_NULLS_LAST

  """in descending order, nulls first"""
  DESC

  """in descending order, nulls first"""
  DESC_NULLS_FIRST

  """in descending order, nulls last"""
  DESC_NULLS_LAST
}

"""
columns and relationships of "promo"
"""
type Promo {
  active: Boolean!
  burnCount: Int!
  campaign: String!

  """An object relationship"""
  campaignObject: Campaign
  createdAt: timestamptz!
  id: String!
  maxBurn: Int
  maxMint: Int
  metadata: String!

  """An object relationship"""
  metadataObject: Metadata
  mint: String!
  mintCount: Int!

  """An object relationship"""
  mintObject: Mint
  modifiedAt: timestamptz!
  slot: bigint!
  writeVersion: bigint!
}

"""
order by aggregate values of table "promo"
"""
input PromoAggregateOrderBy {
  avg: promo_avg_order_by
  count: OrderBy
  max: promo_max_order_by
  min: promo_min_order_by
  stddev: promo_stddev_order_by
  stddev_pop: promo_stddev_pop_order_by
  stddev_samp: promo_stddev_samp_order_by
  sum: promo_sum_order_by
  var_pop: promo_var_pop_order_by
  var_samp: promo_var_samp_order_by
  variance: promo_variance_order_by
}

"""
Boolean expression to filter rows from the table "promo". All fields are combined with a logical 'AND'.
"""
input PromoBoolExp {
  _and: [PromoBoolExp!]
  _not: PromoBoolExp
  _or: [PromoBoolExp!]
  active: BooleanComparisonExp
  burnCount: IntComparisonExp
  campaign: StringComparisonExp
  campaignObject: CampaignBoolExp
  createdAt: TimestamptzComparisonExp
  id: StringComparisonExp
  maxBurn: IntComparisonExp
  maxMint: IntComparisonExp
  metadata: StringComparisonExp
  metadataObject: MetadataBoolExp
  mint: StringComparisonExp
  mintCount: IntComparisonExp
  mintObject: MintBoolExp
  modifiedAt: TimestamptzComparisonExp
  slot: BigintComparisonExp
  writeVersion: BigintComparisonExp
}

"""Ordering options when selecting data from "promo"."""
input PromoOrderBy {
  active: OrderBy
  burnCount: OrderBy
  campaign: OrderBy
  campaignObject: CampaignOrderBy
  createdAt: OrderBy
  id: OrderBy
  maxBurn: OrderBy
  maxMint: OrderBy
  metadata: OrderBy
  metadataObject: MetadataOrderBy
  mint: OrderBy
  mintCount: OrderBy
  mintObject: MintOrderBy
  modifiedAt: OrderBy
  slot: OrderBy
  writeVersion: OrderBy
}

"""
select columns of table "promo"
"""
enum PromoSelectColumn {
  """column name"""
  active

  """column name"""
  burnCount

  """column name"""
  campaign

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  maxBurn

  """column name"""
  maxMint

  """column name"""
  metadata

  """column name"""
  mint

  """column name"""
  mintCount

  """column name"""
  modifiedAt

  """column name"""
  slot

  """column name"""
  writeVersion
}

"""
Streaming cursor of the table "promo"
"""
input PromoStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PromoStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PromoStreamCursorValueInput {
  active: Boolean
  burnCount: Int
  campaign: String
  createdAt: timestamptz
  id: String
  maxBurn: Int
  maxMint: Int
  metadata: String
  mint: String
  mintCount: Int
  modifiedAt: timestamptz
  slot: bigint
  writeVersion: bigint
}

"""
columns and relationships of "promo_transactions"
"""
type PromoTransactions {
  authority: String
  campaign: String
  createdAt: timestamptz
  device: String
  location: String
  memo(
    """JSON select path"""
    path: String
  ): jsonb
  mint: String

  """An object relationship"""
  mintObject: Mint
  modifiedAt: timestamptz
  payer: String
  promo: String
  signature: String
  slot: bigint
  tokenAccount: String

  """An object relationship"""
  tokenAccountObject: TokenAccount
  transactionType: String
}

"""
Boolean expression to filter rows from the table "promo_transactions". All fields are combined with a logical 'AND'.
"""
input PromoTransactionsBoolExp {
  _and: [PromoTransactionsBoolExp!]
  _not: PromoTransactionsBoolExp
  _or: [PromoTransactionsBoolExp!]
  authority: StringComparisonExp
  campaign: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  device: StringComparisonExp
  location: StringComparisonExp
  memo: JsonbComparisonExp
  mint: StringComparisonExp
  mintObject: MintBoolExp
  modifiedAt: TimestamptzComparisonExp
  payer: StringComparisonExp
  promo: StringComparisonExp
  signature: StringComparisonExp
  slot: BigintComparisonExp
  tokenAccount: StringComparisonExp
  tokenAccountObject: TokenAccountBoolExp
  transactionType: StringComparisonExp
}

"""Ordering options when selecting data from "promo_transactions"."""
input PromoTransactionsOrderBy {
  authority: OrderBy
  campaign: OrderBy
  createdAt: OrderBy
  device: OrderBy
  location: OrderBy
  memo: OrderBy
  mint: OrderBy
  mintObject: MintOrderBy
  modifiedAt: OrderBy
  payer: OrderBy
  promo: OrderBy
  signature: OrderBy
  slot: OrderBy
  tokenAccount: OrderBy
  tokenAccountObject: TokenAccountOrderBy
  transactionType: OrderBy
}

"""
select columns of table "promo_transactions"
"""
enum PromoTransactionsSelectColumn {
  """column name"""
  authority

  """column name"""
  campaign

  """column name"""
  createdAt

  """column name"""
  device

  """column name"""
  location

  """column name"""
  memo

  """column name"""
  mint

  """column name"""
  modifiedAt

  """column name"""
  payer

  """column name"""
  promo

  """column name"""
  signature

  """column name"""
  slot

  """column name"""
  tokenAccount

  """column name"""
  transactionType
}

"""
Streaming cursor of the table "promo_transactions"
"""
input PromoTransactionsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PromoTransactionsStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PromoTransactionsStreamCursorValueInput {
  authority: String
  campaign: String
  createdAt: timestamptz
  device: String
  location: String
  memo: jsonb
  mint: String
  modifiedAt: timestamptz
  payer: String
  promo: String
  signature: String
  slot: bigint
  tokenAccount: String
  transactionType: String
}

"""
columns and relationships of "purchase_receipt"
"""
type PurchaseReceipt {
  auctionHouse: String!
  bookkeeper: String!
  bump: Int!
  buyer: String!
  createdAt: timestamptz!
  createdAtOnChain: bigint!
  id: String!
  metadata: String!
  modifiedAt: timestamptz!
  price: bigint!
  seller: String!
  slot: bigint!
  tokenSize: bigint!
  writeVersion: bigint!
}

"""
Boolean expression to filter rows from the table "purchase_receipt". All fields are combined with a logical 'AND'.
"""
input PurchaseReceiptBoolExp {
  _and: [PurchaseReceiptBoolExp!]
  _not: PurchaseReceiptBoolExp
  _or: [PurchaseReceiptBoolExp!]
  auctionHouse: StringComparisonExp
  bookkeeper: StringComparisonExp
  bump: IntComparisonExp
  buyer: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  createdAtOnChain: BigintComparisonExp
  id: StringComparisonExp
  metadata: StringComparisonExp
  modifiedAt: TimestamptzComparisonExp
  price: BigintComparisonExp
  seller: StringComparisonExp
  slot: BigintComparisonExp
  tokenSize: BigintComparisonExp
  writeVersion: BigintComparisonExp
}

"""Ordering options when selecting data from "purchase_receipt"."""
input PurchaseReceiptOrderBy {
  auctionHouse: OrderBy
  bookkeeper: OrderBy
  bump: OrderBy
  buyer: OrderBy
  createdAt: OrderBy
  createdAtOnChain: OrderBy
  id: OrderBy
  metadata: OrderBy
  modifiedAt: OrderBy
  price: OrderBy
  seller: OrderBy
  slot: OrderBy
  tokenSize: OrderBy
  writeVersion: OrderBy
}

"""
select columns of table "purchase_receipt"
"""
enum PurchaseReceiptSelectColumn {
  """column name"""
  auctionHouse

  """column name"""
  bookkeeper

  """column name"""
  bump

  """column name"""
  buyer

  """column name"""
  createdAt

  """column name"""
  createdAtOnChain

  """column name"""
  id

  """column name"""
  metadata

  """column name"""
  modifiedAt

  """column name"""
  price

  """column name"""
  seller

  """column name"""
  slot

  """column name"""
  tokenSize

  """column name"""
  writeVersion
}

"""
Streaming cursor of the table "purchase_receipt"
"""
input PurchaseReceiptStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PurchaseReceiptStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PurchaseReceiptStreamCursorValueInput {
  auctionHouse: String
  bookkeeper: String
  bump: Int
  buyer: String
  createdAt: timestamptz
  createdAtOnChain: bigint
  id: String
  metadata: String
  modifiedAt: timestamptz
  price: bigint
  seller: String
  slot: bigint
  tokenSize: bigint
  writeVersion: bigint
}

"""
columns and relationships of "sign_memo"
"""
type SignMemo {
  createdAt: timestamptz!
  memo(
    """JSON select path"""
    path: String
  ): jsonb

  """An object relationship"""
  merchantObject: Merchant
  modifiedAt: timestamptz!
  payer: String!
  signature: String!
  signer: String!
  slot: bigint!
}

"""
Boolean expression to filter rows from the table "sign_memo". All fields are combined with a logical 'AND'.
"""
input SignMemoBoolExp {
  _and: [SignMemoBoolExp!]
  _not: SignMemoBoolExp
  _or: [SignMemoBoolExp!]
  createdAt: TimestamptzComparisonExp
  memo: JsonbComparisonExp
  merchantObject: MerchantBoolExp
  modifiedAt: TimestamptzComparisonExp
  payer: StringComparisonExp
  signature: StringComparisonExp
  signer: StringComparisonExp
  slot: BigintComparisonExp
}

"""Ordering options when selecting data from "sign_memo"."""
input SignMemoOrderBy {
  createdAt: OrderBy
  memo: OrderBy
  merchantObject: MerchantOrderBy
  modifiedAt: OrderBy
  payer: OrderBy
  signature: OrderBy
  signer: OrderBy
  slot: OrderBy
}

"""
select columns of table "sign_memo"
"""
enum SignMemoSelectColumn {
  """column name"""
  createdAt

  """column name"""
  memo

  """column name"""
  modifiedAt

  """column name"""
  payer

  """column name"""
  signature

  """column name"""
  signer

  """column name"""
  slot
}

"""
Streaming cursor of the table "sign_memo"
"""
input SignMemoStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: SignMemoStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input SignMemoStreamCursorValueInput {
  createdAt: timestamptz
  memo: jsonb
  modifiedAt: timestamptz
  payer: String
  signature: String
  signer: String
  slot: bigint
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input StringComparisonExp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _isNull: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input TimestamptzComparisonExp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _isNull: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"""
columns and relationships of "token_account"
"""
type TokenAccount {
  amount: bigint!
  closeAuthority: String
  createdAt: timestamptz!
  delegate: String
  delegatedAmount: bigint
  id: String!
  isNative: bigint
  mint: String!

  """An object relationship"""
  mintObject: Mint
  modifiedAt: timestamptz!
  owner: String!
  slot: bigint!
  state: String!
  writeVersion: bigint!
}

"""
order by aggregate values of table "token_account"
"""
input TokenAccountAggregateOrderBy {
  avg: token_account_avg_order_by
  count: OrderBy
  max: token_account_max_order_by
  min: token_account_min_order_by
  stddev: token_account_stddev_order_by
  stddev_pop: token_account_stddev_pop_order_by
  stddev_samp: token_account_stddev_samp_order_by
  sum: token_account_sum_order_by
  var_pop: token_account_var_pop_order_by
  var_samp: token_account_var_samp_order_by
  variance: token_account_variance_order_by
}

"""
Boolean expression to filter rows from the table "token_account". All fields are combined with a logical 'AND'.
"""
input TokenAccountBoolExp {
  _and: [TokenAccountBoolExp!]
  _not: TokenAccountBoolExp
  _or: [TokenAccountBoolExp!]
  amount: BigintComparisonExp
  closeAuthority: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  delegate: StringComparisonExp
  delegatedAmount: BigintComparisonExp
  id: StringComparisonExp
  isNative: BigintComparisonExp
  mint: StringComparisonExp
  mintObject: MintBoolExp
  modifiedAt: TimestamptzComparisonExp
  owner: StringComparisonExp
  slot: BigintComparisonExp
  state: StringComparisonExp
  writeVersion: BigintComparisonExp
}

"""Ordering options when selecting data from "token_account"."""
input TokenAccountOrderBy {
  amount: OrderBy
  closeAuthority: OrderBy
  createdAt: OrderBy
  delegate: OrderBy
  delegatedAmount: OrderBy
  id: OrderBy
  isNative: OrderBy
  mint: OrderBy
  mintObject: MintOrderBy
  modifiedAt: OrderBy
  owner: OrderBy
  slot: OrderBy
  state: OrderBy
  writeVersion: OrderBy
}

"""
select columns of table "token_account"
"""
enum TokenAccountSelectColumn {
  """column name"""
  amount

  """column name"""
  closeAuthority

  """column name"""
  createdAt

  """column name"""
  delegate

  """column name"""
  delegatedAmount

  """column name"""
  id

  """column name"""
  isNative

  """column name"""
  mint

  """column name"""
  modifiedAt

  """column name"""
  owner

  """column name"""
  slot

  """column name"""
  state

  """column name"""
  writeVersion
}

"""
Streaming cursor of the table "token_account"
"""
input TokenAccountStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: TokenAccountStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input TokenAccountStreamCursorValueInput {
  amount: bigint
  closeAuthority: String
  createdAt: timestamptz
  delegate: String
  delegatedAmount: bigint
  id: String
  isNative: bigint
  mint: String
  modifiedAt: timestamptz
  owner: String
  slot: bigint
  state: String
  writeVersion: bigint
}

scalar bigint

"""
order by avg() on columns of table "campaign"
"""
input campaign_avg_order_by {
  slot: OrderBy
  writeVersion: OrderBy
}

"""
order by max() on columns of table "campaign"
"""
input campaign_max_order_by {
  createdAt: OrderBy
  id: OrderBy
  merchant: OrderBy
  modifiedAt: OrderBy
  name: OrderBy
  slot: OrderBy
  uri: OrderBy
  writeVersion: OrderBy
}

"""
order by min() on columns of table "campaign"
"""
input campaign_min_order_by {
  createdAt: OrderBy
  id: OrderBy
  merchant: OrderBy
  modifiedAt: OrderBy
  name: OrderBy
  slot: OrderBy
  uri: OrderBy
  writeVersion: OrderBy
}

"""
order by stddev() on columns of table "campaign"
"""
input campaign_stddev_order_by {
  slot: OrderBy
  writeVersion: OrderBy
}

"""
order by stddev_pop() on columns of table "campaign"
"""
input campaign_stddev_pop_order_by {
  slot: OrderBy
  writeVersion: OrderBy
}

"""
order by stddev_samp() on columns of table "campaign"
"""
input campaign_stddev_samp_order_by {
  slot: OrderBy
  writeVersion: OrderBy
}

"""
order by sum() on columns of table "campaign"
"""
input campaign_sum_order_by {
  slot: OrderBy
  writeVersion: OrderBy
}

"""
order by var_pop() on columns of table "campaign"
"""
input campaign_var_pop_order_by {
  slot: OrderBy
  writeVersion: OrderBy
}

"""
order by var_samp() on columns of table "campaign"
"""
input campaign_var_samp_order_by {
  slot: OrderBy
  writeVersion: OrderBy
}

"""
order by variance() on columns of table "campaign"
"""
input campaign_variance_order_by {
  slot: OrderBy
  writeVersion: OrderBy
}

input device_aggregate_bool_exp {
  bool_and: device_aggregate_bool_exp_bool_and
  bool_or: device_aggregate_bool_exp_bool_or
  count: device_aggregate_bool_exp_count
}

input device_aggregate_bool_exp_bool_and {
  arguments: device_select_column_device_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: DeviceBoolExp
  predicate: BooleanComparisonExp!
}

input device_aggregate_bool_exp_bool_or {
  arguments: device_select_column_device_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: DeviceBoolExp
  predicate: BooleanComparisonExp!
}

input device_aggregate_bool_exp_count {
  arguments: [DeviceSelectColumn!]
  distinct: Boolean
  filter: DeviceBoolExp
  predicate: IntComparisonExp!
}

"""
order by avg() on columns of table "device"
"""
input device_avg_order_by {
  slot: OrderBy
  writeVersion: OrderBy
}

"""
order by max() on columns of table "device"
"""
input device_max_order_by {
  createdAt: OrderBy
  id: OrderBy
  location: OrderBy
  modifiedAt: OrderBy
  name: OrderBy
  owner: OrderBy
  slot: OrderBy
  uri: OrderBy
  writeVersion: OrderBy
}

"""
order by min() on columns of table "device"
"""
input device_min_order_by {
  createdAt: OrderBy
  id: OrderBy
  location: OrderBy
  modifiedAt: OrderBy
  name: OrderBy
  owner: OrderBy
  slot: OrderBy
  uri: OrderBy
  writeVersion: OrderBy
}

"""
select "device_aggregate_bool_exp_bool_and_arguments_columns" columns of table "device"
"""
enum device_select_column_device_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  active
}

"""
select "device_aggregate_bool_exp_bool_or_arguments_columns" columns of table "device"
"""
enum device_select_column_device_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  active
}

"""
order by stddev() on columns of table "device"
"""
input device_stddev_order_by {
  slot: OrderBy
  writeVersion: OrderBy
}

"""
order by stddev_pop() on columns of table "device"
"""
input device_stddev_pop_order_by {
  slot: OrderBy
  writeVersion: OrderBy
}

"""
order by stddev_samp() on columns of table "device"
"""
input device_stddev_samp_order_by {
  slot: OrderBy
  writeVersion: OrderBy
}

"""
order by sum() on columns of table "device"
"""
input device_sum_order_by {
  slot: OrderBy
  writeVersion: OrderBy
}

"""
order by var_pop() on columns of table "device"
"""
input device_var_pop_order_by {
  slot: OrderBy
  writeVersion: OrderBy
}

"""
order by var_samp() on columns of table "device"
"""
input device_var_samp_order_by {
  slot: OrderBy
  writeVersion: OrderBy
}

"""
order by variance() on columns of table "device"
"""
input device_variance_order_by {
  slot: OrderBy
  writeVersion: OrderBy
}

scalar jsonb

"""
order by avg() on columns of table "location"
"""
input location_avg_order_by {
  slot: OrderBy
  writeVersion: OrderBy
}

"""
order by max() on columns of table "location"
"""
input location_max_order_by {
  createdAt: OrderBy
  id: OrderBy
  merchant: OrderBy
  modifiedAt: OrderBy
  name: OrderBy
  slot: OrderBy
  uri: OrderBy
  writeVersion: OrderBy
}

"""
order by min() on columns of table "location"
"""
input location_min_order_by {
  createdAt: OrderBy
  id: OrderBy
  merchant: OrderBy
  modifiedAt: OrderBy
  name: OrderBy
  slot: OrderBy
  uri: OrderBy
  writeVersion: OrderBy
}

"""
order by stddev() on columns of table "location"
"""
input location_stddev_order_by {
  slot: OrderBy
  writeVersion: OrderBy
}

"""
order by stddev_pop() on columns of table "location"
"""
input location_stddev_pop_order_by {
  slot: OrderBy
  writeVersion: OrderBy
}

"""
order by stddev_samp() on columns of table "location"
"""
input location_stddev_samp_order_by {
  slot: OrderBy
  writeVersion: OrderBy
}

"""
order by sum() on columns of table "location"
"""
input location_sum_order_by {
  slot: OrderBy
  writeVersion: OrderBy
}

"""
order by var_pop() on columns of table "location"
"""
input location_var_pop_order_by {
  slot: OrderBy
  writeVersion: OrderBy
}

"""
order by var_samp() on columns of table "location"
"""
input location_var_samp_order_by {
  slot: OrderBy
  writeVersion: OrderBy
}

"""
order by variance() on columns of table "location"
"""
input location_variance_order_by {
  slot: OrderBy
  writeVersion: OrderBy
}

"""
order by avg() on columns of table "promo"
"""
input promo_avg_order_by {
  burnCount: OrderBy
  maxBurn: OrderBy
  maxMint: OrderBy
  mintCount: OrderBy
  slot: OrderBy
  writeVersion: OrderBy
}

"""
order by max() on columns of table "promo"
"""
input promo_max_order_by {
  burnCount: OrderBy
  campaign: OrderBy
  createdAt: OrderBy
  id: OrderBy
  maxBurn: OrderBy
  maxMint: OrderBy
  metadata: OrderBy
  mint: OrderBy
  mintCount: OrderBy
  modifiedAt: OrderBy
  slot: OrderBy
  writeVersion: OrderBy
}

"""
order by min() on columns of table "promo"
"""
input promo_min_order_by {
  burnCount: OrderBy
  campaign: OrderBy
  createdAt: OrderBy
  id: OrderBy
  maxBurn: OrderBy
  maxMint: OrderBy
  metadata: OrderBy
  mint: OrderBy
  mintCount: OrderBy
  modifiedAt: OrderBy
  slot: OrderBy
  writeVersion: OrderBy
}

"""
order by stddev() on columns of table "promo"
"""
input promo_stddev_order_by {
  burnCount: OrderBy
  maxBurn: OrderBy
  maxMint: OrderBy
  mintCount: OrderBy
  slot: OrderBy
  writeVersion: OrderBy
}

"""
order by stddev_pop() on columns of table "promo"
"""
input promo_stddev_pop_order_by {
  burnCount: OrderBy
  maxBurn: OrderBy
  maxMint: OrderBy
  mintCount: OrderBy
  slot: OrderBy
  writeVersion: OrderBy
}

"""
order by stddev_samp() on columns of table "promo"
"""
input promo_stddev_samp_order_by {
  burnCount: OrderBy
  maxBurn: OrderBy
  maxMint: OrderBy
  mintCount: OrderBy
  slot: OrderBy
  writeVersion: OrderBy
}

"""
order by sum() on columns of table "promo"
"""
input promo_sum_order_by {
  burnCount: OrderBy
  maxBurn: OrderBy
  maxMint: OrderBy
  mintCount: OrderBy
  slot: OrderBy
  writeVersion: OrderBy
}

"""
order by var_pop() on columns of table "promo"
"""
input promo_var_pop_order_by {
  burnCount: OrderBy
  maxBurn: OrderBy
  maxMint: OrderBy
  mintCount: OrderBy
  slot: OrderBy
  writeVersion: OrderBy
}

"""
order by var_samp() on columns of table "promo"
"""
input promo_var_samp_order_by {
  burnCount: OrderBy
  maxBurn: OrderBy
  maxMint: OrderBy
  mintCount: OrderBy
  slot: OrderBy
  writeVersion: OrderBy
}

"""
order by variance() on columns of table "promo"
"""
input promo_variance_order_by {
  burnCount: OrderBy
  maxBurn: OrderBy
  maxMint: OrderBy
  mintCount: OrderBy
  slot: OrderBy
  writeVersion: OrderBy
}

type query_root {
  """
  fetch data from the table: "bid_receipt"
  """
  bidReceipt(
    """distinct select on columns"""
    distinctOn: [BidReceiptSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [BidReceiptOrderBy!]

    """filter the rows returned"""
    where: BidReceiptBoolExp
  ): [BidReceipt!]!

  """fetch data from the table: "bid_receipt" using primary key columns"""
  bidReceiptByPk(id: String!): BidReceipt

  """
  fetch data from the table: "burn_delegated_promo_token"
  """
  burnDelegatedPromoToken(
    """distinct select on columns"""
    distinctOn: [BurnDelegatedPromoTokenSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [BurnDelegatedPromoTokenOrderBy!]

    """filter the rows returned"""
    where: BurnDelegatedPromoTokenBoolExp
  ): [BurnDelegatedPromoToken!]!

  """
  fetch data from the table: "burn_delegated_promo_token" using primary key columns
  """
  burnDelegatedPromoTokenByPk(signature: String!): BurnDelegatedPromoToken

  """
  fetch data from the table: "campaign"
  """
  campaign(
    """distinct select on columns"""
    distinctOn: [CampaignSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CampaignOrderBy!]

    """filter the rows returned"""
    where: CampaignBoolExp
  ): [Campaign!]!

  """fetch data from the table: "campaign" using primary key columns"""
  campaignByPk(id: String!): Campaign

  """
  fetch data from the table: "delegate_promo_token"
  """
  delegatePromoToken(
    """distinct select on columns"""
    distinctOn: [DelegatePromoTokenSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [DelegatePromoTokenOrderBy!]

    """filter the rows returned"""
    where: DelegatePromoTokenBoolExp
  ): [DelegatePromoToken!]!

  """
  fetch data from the table: "delegate_promo_token" using primary key columns
  """
  delegatePromoTokenByPk(signature: String!): DelegatePromoToken

  """
  fetch data from the table: "device"
  """
  device(
    """distinct select on columns"""
    distinctOn: [DeviceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [DeviceOrderBy!]

    """filter the rows returned"""
    where: DeviceBoolExp
  ): [Device!]!

  """
  fetch aggregated fields from the table: "device"
  """
  deviceAggregate(
    """distinct select on columns"""
    distinctOn: [DeviceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [DeviceOrderBy!]

    """filter the rows returned"""
    where: DeviceBoolExp
  ): DeviceAggregate!

  """fetch data from the table: "device" using primary key columns"""
  deviceByPk(id: String!): Device

  """
  fetch data from the table: "listing_receipt"
  """
  listingReceipt(
    """distinct select on columns"""
    distinctOn: [ListingReceiptSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ListingReceiptOrderBy!]

    """filter the rows returned"""
    where: ListingReceiptBoolExp
  ): [ListingReceipt!]!

  """fetch data from the table: "listing_receipt" using primary key columns"""
  listingReceiptByPk(id: String!): ListingReceipt

  """
  fetch data from the table: "listing_with_token"
  """
  listingWithToken(
    """distinct select on columns"""
    distinctOn: [ListingWithTokenSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ListingWithTokenOrderBy!]

    """filter the rows returned"""
    where: ListingWithTokenBoolExp
  ): [ListingWithToken!]!

  """
  fetch data from the table: "location"
  """
  location(
    """distinct select on columns"""
    distinctOn: [LocationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [LocationOrderBy!]

    """filter the rows returned"""
    where: LocationBoolExp
  ): [Location!]!

  """fetch data from the table: "location" using primary key columns"""
  locationByPk(id: String!): Location

  """
  fetch data from the table: "merchant"
  """
  merchant(
    """distinct select on columns"""
    distinctOn: [MerchantSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MerchantOrderBy!]

    """filter the rows returned"""
    where: MerchantBoolExp
  ): [Merchant!]!

  """fetch data from the table: "merchant" using primary key columns"""
  merchantByPk(id: String!): Merchant

  """
  fetch data from the table: "metadata"
  """
  metadata(
    """distinct select on columns"""
    distinctOn: [MetadataSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MetadataOrderBy!]

    """filter the rows returned"""
    where: MetadataBoolExp
  ): [Metadata!]!

  """fetch data from the table: "metadata" using primary key columns"""
  metadataByPk(id: String!): Metadata

  """
  fetch data from the table: "mint"
  """
  mint(
    """distinct select on columns"""
    distinctOn: [MintSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MintOrderBy!]

    """filter the rows returned"""
    where: MintBoolExp
  ): [Mint!]!

  """fetch data from the table: "mint" using primary key columns"""
  mintByPk(id: String!): Mint

  """
  fetch data from the table: "mint_promo_token"
  """
  mintPromoToken(
    """distinct select on columns"""
    distinctOn: [MintPromoTokenSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MintPromoTokenOrderBy!]

    """filter the rows returned"""
    where: MintPromoTokenBoolExp
  ): [MintPromoToken!]!

  """
  fetch data from the table: "mint_promo_token" using primary key columns
  """
  mintPromoTokenByPk(signature: String!): MintPromoToken

  """
  fetch data from the table: "promo"
  """
  promo(
    """distinct select on columns"""
    distinctOn: [PromoSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromoOrderBy!]

    """filter the rows returned"""
    where: PromoBoolExp
  ): [Promo!]!

  """fetch data from the table: "promo" using primary key columns"""
  promoByPk(id: String!): Promo

  """
  fetch data from the table: "promo_transactions"
  """
  promoTransactions(
    """distinct select on columns"""
    distinctOn: [PromoTransactionsSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromoTransactionsOrderBy!]

    """filter the rows returned"""
    where: PromoTransactionsBoolExp
  ): [PromoTransactions!]!

  """
  fetch data from the table: "purchase_receipt"
  """
  purchaseReceipt(
    """distinct select on columns"""
    distinctOn: [PurchaseReceiptSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PurchaseReceiptOrderBy!]

    """filter the rows returned"""
    where: PurchaseReceiptBoolExp
  ): [PurchaseReceipt!]!

  """
  fetch data from the table: "purchase_receipt" using primary key columns
  """
  purchaseReceiptByPk(id: String!): PurchaseReceipt

  """
  fetch data from the table: "sign_memo"
  """
  signMemo(
    """distinct select on columns"""
    distinctOn: [SignMemoSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [SignMemoOrderBy!]

    """filter the rows returned"""
    where: SignMemoBoolExp
  ): [SignMemo!]!

  """fetch data from the table: "sign_memo" using primary key columns"""
  signMemoByPk(signature: String!): SignMemo

  """
  fetch data from the table: "token_account"
  """
  tokenAccount(
    """distinct select on columns"""
    distinctOn: [TokenAccountSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TokenAccountOrderBy!]

    """filter the rows returned"""
    where: TokenAccountBoolExp
  ): [TokenAccount!]!

  """fetch data from the table: "token_account" using primary key columns"""
  tokenAccountByPk(id: String!): TokenAccount
}

type subscription_root {
  """
  fetch data from the table: "bid_receipt"
  """
  bidReceipt(
    """distinct select on columns"""
    distinctOn: [BidReceiptSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [BidReceiptOrderBy!]

    """filter the rows returned"""
    where: BidReceiptBoolExp
  ): [BidReceipt!]!

  """fetch data from the table: "bid_receipt" using primary key columns"""
  bidReceiptByPk(id: String!): BidReceipt

  """
  fetch data from the table in a streaming manner: "bid_receipt"
  """
  bidReceiptStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [BidReceiptStreamCursorInput]!

    """filter the rows returned"""
    where: BidReceiptBoolExp
  ): [BidReceipt!]!

  """
  fetch data from the table: "burn_delegated_promo_token"
  """
  burnDelegatedPromoToken(
    """distinct select on columns"""
    distinctOn: [BurnDelegatedPromoTokenSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [BurnDelegatedPromoTokenOrderBy!]

    """filter the rows returned"""
    where: BurnDelegatedPromoTokenBoolExp
  ): [BurnDelegatedPromoToken!]!

  """
  fetch data from the table: "burn_delegated_promo_token" using primary key columns
  """
  burnDelegatedPromoTokenByPk(signature: String!): BurnDelegatedPromoToken

  """
  fetch data from the table in a streaming manner: "burn_delegated_promo_token"
  """
  burnDelegatedPromoTokenStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [BurnDelegatedPromoTokenStreamCursorInput]!

    """filter the rows returned"""
    where: BurnDelegatedPromoTokenBoolExp
  ): [BurnDelegatedPromoToken!]!

  """
  fetch data from the table: "campaign"
  """
  campaign(
    """distinct select on columns"""
    distinctOn: [CampaignSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CampaignOrderBy!]

    """filter the rows returned"""
    where: CampaignBoolExp
  ): [Campaign!]!

  """fetch data from the table: "campaign" using primary key columns"""
  campaignByPk(id: String!): Campaign

  """
  fetch data from the table in a streaming manner: "campaign"
  """
  campaignStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [CampaignStreamCursorInput]!

    """filter the rows returned"""
    where: CampaignBoolExp
  ): [Campaign!]!

  """
  fetch data from the table: "delegate_promo_token"
  """
  delegatePromoToken(
    """distinct select on columns"""
    distinctOn: [DelegatePromoTokenSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [DelegatePromoTokenOrderBy!]

    """filter the rows returned"""
    where: DelegatePromoTokenBoolExp
  ): [DelegatePromoToken!]!

  """
  fetch data from the table: "delegate_promo_token" using primary key columns
  """
  delegatePromoTokenByPk(signature: String!): DelegatePromoToken

  """
  fetch data from the table in a streaming manner: "delegate_promo_token"
  """
  delegatePromoTokenStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [DelegatePromoTokenStreamCursorInput]!

    """filter the rows returned"""
    where: DelegatePromoTokenBoolExp
  ): [DelegatePromoToken!]!

  """
  fetch data from the table: "device"
  """
  device(
    """distinct select on columns"""
    distinctOn: [DeviceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [DeviceOrderBy!]

    """filter the rows returned"""
    where: DeviceBoolExp
  ): [Device!]!

  """
  fetch aggregated fields from the table: "device"
  """
  deviceAggregate(
    """distinct select on columns"""
    distinctOn: [DeviceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [DeviceOrderBy!]

    """filter the rows returned"""
    where: DeviceBoolExp
  ): DeviceAggregate!

  """fetch data from the table: "device" using primary key columns"""
  deviceByPk(id: String!): Device

  """
  fetch data from the table in a streaming manner: "device"
  """
  deviceStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [DeviceStreamCursorInput]!

    """filter the rows returned"""
    where: DeviceBoolExp
  ): [Device!]!

  """
  fetch data from the table: "listing_receipt"
  """
  listingReceipt(
    """distinct select on columns"""
    distinctOn: [ListingReceiptSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ListingReceiptOrderBy!]

    """filter the rows returned"""
    where: ListingReceiptBoolExp
  ): [ListingReceipt!]!

  """fetch data from the table: "listing_receipt" using primary key columns"""
  listingReceiptByPk(id: String!): ListingReceipt

  """
  fetch data from the table in a streaming manner: "listing_receipt"
  """
  listingReceiptStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ListingReceiptStreamCursorInput]!

    """filter the rows returned"""
    where: ListingReceiptBoolExp
  ): [ListingReceipt!]!

  """
  fetch data from the table: "listing_with_token"
  """
  listingWithToken(
    """distinct select on columns"""
    distinctOn: [ListingWithTokenSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ListingWithTokenOrderBy!]

    """filter the rows returned"""
    where: ListingWithTokenBoolExp
  ): [ListingWithToken!]!

  """
  fetch data from the table in a streaming manner: "listing_with_token"
  """
  listingWithTokenStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ListingWithTokenStreamCursorInput]!

    """filter the rows returned"""
    where: ListingWithTokenBoolExp
  ): [ListingWithToken!]!

  """
  fetch data from the table: "location"
  """
  location(
    """distinct select on columns"""
    distinctOn: [LocationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [LocationOrderBy!]

    """filter the rows returned"""
    where: LocationBoolExp
  ): [Location!]!

  """fetch data from the table: "location" using primary key columns"""
  locationByPk(id: String!): Location

  """
  fetch data from the table in a streaming manner: "location"
  """
  locationStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [LocationStreamCursorInput]!

    """filter the rows returned"""
    where: LocationBoolExp
  ): [Location!]!

  """
  fetch data from the table: "merchant"
  """
  merchant(
    """distinct select on columns"""
    distinctOn: [MerchantSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MerchantOrderBy!]

    """filter the rows returned"""
    where: MerchantBoolExp
  ): [Merchant!]!

  """fetch data from the table: "merchant" using primary key columns"""
  merchantByPk(id: String!): Merchant

  """
  fetch data from the table in a streaming manner: "merchant"
  """
  merchantStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [MerchantStreamCursorInput]!

    """filter the rows returned"""
    where: MerchantBoolExp
  ): [Merchant!]!

  """
  fetch data from the table: "metadata"
  """
  metadata(
    """distinct select on columns"""
    distinctOn: [MetadataSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MetadataOrderBy!]

    """filter the rows returned"""
    where: MetadataBoolExp
  ): [Metadata!]!

  """fetch data from the table: "metadata" using primary key columns"""
  metadataByPk(id: String!): Metadata

  """
  fetch data from the table in a streaming manner: "metadata"
  """
  metadataStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [MetadataStreamCursorInput]!

    """filter the rows returned"""
    where: MetadataBoolExp
  ): [Metadata!]!

  """
  fetch data from the table: "mint"
  """
  mint(
    """distinct select on columns"""
    distinctOn: [MintSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MintOrderBy!]

    """filter the rows returned"""
    where: MintBoolExp
  ): [Mint!]!

  """fetch data from the table: "mint" using primary key columns"""
  mintByPk(id: String!): Mint

  """
  fetch data from the table: "mint_promo_token"
  """
  mintPromoToken(
    """distinct select on columns"""
    distinctOn: [MintPromoTokenSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MintPromoTokenOrderBy!]

    """filter the rows returned"""
    where: MintPromoTokenBoolExp
  ): [MintPromoToken!]!

  """
  fetch data from the table: "mint_promo_token" using primary key columns
  """
  mintPromoTokenByPk(signature: String!): MintPromoToken

  """
  fetch data from the table in a streaming manner: "mint_promo_token"
  """
  mintPromoTokenStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [MintPromoTokenStreamCursorInput]!

    """filter the rows returned"""
    where: MintPromoTokenBoolExp
  ): [MintPromoToken!]!

  """
  fetch data from the table in a streaming manner: "mint"
  """
  mintStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [MintStreamCursorInput]!

    """filter the rows returned"""
    where: MintBoolExp
  ): [Mint!]!

  """
  fetch data from the table: "promo"
  """
  promo(
    """distinct select on columns"""
    distinctOn: [PromoSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromoOrderBy!]

    """filter the rows returned"""
    where: PromoBoolExp
  ): [Promo!]!

  """fetch data from the table: "promo" using primary key columns"""
  promoByPk(id: String!): Promo

  """
  fetch data from the table in a streaming manner: "promo"
  """
  promoStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [PromoStreamCursorInput]!

    """filter the rows returned"""
    where: PromoBoolExp
  ): [Promo!]!

  """
  fetch data from the table: "promo_transactions"
  """
  promoTransactions(
    """distinct select on columns"""
    distinctOn: [PromoTransactionsSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromoTransactionsOrderBy!]

    """filter the rows returned"""
    where: PromoTransactionsBoolExp
  ): [PromoTransactions!]!

  """
  fetch data from the table in a streaming manner: "promo_transactions"
  """
  promoTransactionsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [PromoTransactionsStreamCursorInput]!

    """filter the rows returned"""
    where: PromoTransactionsBoolExp
  ): [PromoTransactions!]!

  """
  fetch data from the table: "purchase_receipt"
  """
  purchaseReceipt(
    """distinct select on columns"""
    distinctOn: [PurchaseReceiptSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PurchaseReceiptOrderBy!]

    """filter the rows returned"""
    where: PurchaseReceiptBoolExp
  ): [PurchaseReceipt!]!

  """
  fetch data from the table: "purchase_receipt" using primary key columns
  """
  purchaseReceiptByPk(id: String!): PurchaseReceipt

  """
  fetch data from the table in a streaming manner: "purchase_receipt"
  """
  purchaseReceiptStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [PurchaseReceiptStreamCursorInput]!

    """filter the rows returned"""
    where: PurchaseReceiptBoolExp
  ): [PurchaseReceipt!]!

  """
  fetch data from the table: "sign_memo"
  """
  signMemo(
    """distinct select on columns"""
    distinctOn: [SignMemoSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [SignMemoOrderBy!]

    """filter the rows returned"""
    where: SignMemoBoolExp
  ): [SignMemo!]!

  """fetch data from the table: "sign_memo" using primary key columns"""
  signMemoByPk(signature: String!): SignMemo

  """
  fetch data from the table in a streaming manner: "sign_memo"
  """
  signMemoStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [SignMemoStreamCursorInput]!

    """filter the rows returned"""
    where: SignMemoBoolExp
  ): [SignMemo!]!

  """
  fetch data from the table: "token_account"
  """
  tokenAccount(
    """distinct select on columns"""
    distinctOn: [TokenAccountSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TokenAccountOrderBy!]

    """filter the rows returned"""
    where: TokenAccountBoolExp
  ): [TokenAccount!]!

  """fetch data from the table: "token_account" using primary key columns"""
  tokenAccountByPk(id: String!): TokenAccount

  """
  fetch data from the table in a streaming manner: "token_account"
  """
  tokenAccountStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [TokenAccountStreamCursorInput]!

    """filter the rows returned"""
    where: TokenAccountBoolExp
  ): [TokenAccount!]!
}

scalar timestamptz

"""
order by avg() on columns of table "token_account"
"""
input token_account_avg_order_by {
  amount: OrderBy
  delegatedAmount: OrderBy
  isNative: OrderBy
  slot: OrderBy
  writeVersion: OrderBy
}

"""
order by max() on columns of table "token_account"
"""
input token_account_max_order_by {
  amount: OrderBy
  closeAuthority: OrderBy
  createdAt: OrderBy
  delegate: OrderBy
  delegatedAmount: OrderBy
  id: OrderBy
  isNative: OrderBy
  mint: OrderBy
  modifiedAt: OrderBy
  owner: OrderBy
  slot: OrderBy
  state: OrderBy
  writeVersion: OrderBy
}

"""
order by min() on columns of table "token_account"
"""
input token_account_min_order_by {
  amount: OrderBy
  closeAuthority: OrderBy
  createdAt: OrderBy
  delegate: OrderBy
  delegatedAmount: OrderBy
  id: OrderBy
  isNative: OrderBy
  mint: OrderBy
  modifiedAt: OrderBy
  owner: OrderBy
  slot: OrderBy
  state: OrderBy
  writeVersion: OrderBy
}

"""
order by stddev() on columns of table "token_account"
"""
input token_account_stddev_order_by {
  amount: OrderBy
  delegatedAmount: OrderBy
  isNative: OrderBy
  slot: OrderBy
  writeVersion: OrderBy
}

"""
order by stddev_pop() on columns of table "token_account"
"""
input token_account_stddev_pop_order_by {
  amount: OrderBy
  delegatedAmount: OrderBy
  isNative: OrderBy
  slot: OrderBy
  writeVersion: OrderBy
}

"""
order by stddev_samp() on columns of table "token_account"
"""
input token_account_stddev_samp_order_by {
  amount: OrderBy
  delegatedAmount: OrderBy
  isNative: OrderBy
  slot: OrderBy
  writeVersion: OrderBy
}

"""
order by sum() on columns of table "token_account"
"""
input token_account_sum_order_by {
  amount: OrderBy
  delegatedAmount: OrderBy
  isNative: OrderBy
  slot: OrderBy
  writeVersion: OrderBy
}

"""
order by var_pop() on columns of table "token_account"
"""
input token_account_var_pop_order_by {
  amount: OrderBy
  delegatedAmount: OrderBy
  isNative: OrderBy
  slot: OrderBy
  writeVersion: OrderBy
}

"""
order by var_samp() on columns of table "token_account"
"""
input token_account_var_samp_order_by {
  amount: OrderBy
  delegatedAmount: OrderBy
  isNative: OrderBy
  slot: OrderBy
  writeVersion: OrderBy
}

"""
order by variance() on columns of table "token_account"
"""
input token_account_variance_order_by {
  amount: OrderBy
  delegatedAmount: OrderBy
  isNative: OrderBy
  slot: OrderBy
  writeVersion: OrderBy
}

